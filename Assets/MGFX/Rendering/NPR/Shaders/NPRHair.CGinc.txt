/// Vertex
///
struct appdata
{
    float4 vertex : POSITION;
    float3 normal : NORMAL;
    float4 vcolor : COLOR;
    float2 texcoord : TEXCOORD0;

#if _NORMAL_MAP_ON
	float4 tangent : TANGENT;
#endif
};

struct v2f
{
	float4 vcolor : COLOR;
    float4 uv : TEXCOORD0;
    SHADOW_COORDS(1) // put shadows data into TEXCOORD1
    float4 worldPosAndZ : TEXCOORD2;

#if _NORMAL_MAP_ON
	float4 tanSpace0 : TEXCOORD3;
	float4 tanSpace1 : TEXCOORD4;
	float4 tanSpace2 : TEXCOORD5;
#else
	float3 worldNormal : TEXCOORD3;
#endif

    float4 pos : SV_POSITION;
};

v2f vert (appdata v)
{
    v2f o;
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
    o.vcolor = v.vcolor;
    o.uv = v.texcoord.xyxy;
    float3 worldNormal = UnityObjectToWorldNormal(v.normal);

#if _NORMAL_MAP_ON
	float3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
	float tangentSign = v.tangent.w * unity_WorldTransformParams.w;
	float3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
	o.tanSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, 0);
	o.tanSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, 0);
	o.tanSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, 0);
#else
	o.worldNormal = worldNormal;
#endif

    o.worldPosAndZ.xyz = mul(unity_ObjectToWorld, v.vertex).xyz;

    COMPUTE_EYEDEPTH(o.worldPosAndZ.w);
    // compute shadows data
    TRANSFER_SHADOW(o)
    return o;
}

///
/// Fragment
///
uniform sampler2D _MainTex;
uniform sampler2D _DiffuseLUTTex;
uniform sampler2D _SpecularLUTTex;

uniform float _FadeOut;

uniform sampler2D _MudSSAOTex; // global property

#if _NORMAL_MAP_ON
uniform sampler2D _NormalMapTex;
#endif

#if _DIM_ON
uniform sampler2D _DimTex;
#endif

#if _RIM_ON
uniform sampler2D _RimLUTTex;
uniform float _RimIntensity;
#endif

struct ShadingContext
{
	half4 albedo;
	half4 dimmed;
	half3 worldNormal;
	half3 worldViewDir;
	half3 worldPos;
	fixed vface;
	fixed shadow;
	half4 result;
};

void fetchWorldNormal(inout ShadingContext ctx, in v2f i)
{
#if _NORMAL_MAP_ON
	half3 tanNormal = UnpackNormal(tex2D(_NormalMapTex, i.uv.xy));
	half3 worldNormal;
	worldNormal.x = dot(i.tanSpace0.xyz, tanNormal);
	worldNormal.y = dot(i.tanSpace1.xyz, tanNormal);
	worldNormal.z = dot(i.tanSpace2.xyz, tanNormal);
	ctx.worldNormal = normalize(worldNormal);
#else
	ctx.worldNormal = normalize(i.worldNormal);
#endif

#ifdef BACKFACE_ON
	ctx.worldNormal *= -1;
#endif

	ctx.worldPos = i.worldPosAndZ.xyz;
	ctx.worldViewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPosAndZ.xyz);

}

void fetchShadowTerm(inout ShadingContext ctx, in v2f i)
{
#if !defined(BACKFACE_ON)
	ctx.shadow = SHADOW_ATTENUATION(i);
#else
	ctx.shadow = 1;
#endif
}

void fetchAlbedoAndDimmed(inout ShadingContext ctx, in v2f i)
{
	ctx.albedo = tex2D(_MainTex, i.uv.xy);

#if _DIM_ON
	ctx.dimmed = tex2D(_DimTex, i.uv.xy);
#else
	half3 dimmed = ctx.albedo.rgb * 0.875;
	dimmed = dimmed * dimmed;
	ctx.dimmed = half4(dimmed, ctx.albedo.a);
#endif
}

void applyLightingFwdBase(inout ShadingContext ctx, in v2f i)
{
	half2 screenuv = i.pos.xy * _ScreenParams.zw - i.pos.xy;
	half occl = tex2D(_MudSSAOTex, screenuv).r;
	occl = saturate(occl * occl * 4);
	occl = 1 - occl;

	half ndotl = dot(ctx.worldNormal, autoLightDir());
	ndotl = tex2D(_DiffuseLUTTex, saturate(ndotl * 0.5 + 0.5) * ctx.shadow).r;
	ndotl = lerp(1.0, ndotl * occl, i.vcolor.a);

	half3 lighting = lerp(ctx.dimmed, ctx.albedo, ndotl) * _LightColor0.rgb;

	ctx.result.rgb += lighting;
}

void applyLightingFwdAdd(inout ShadingContext ctx, in v2f i)
{
    UNITY_LIGHT_ATTENUATION(lightShadowAndAtten, i, i.worldPosAndZ.xyz);

	half ndotl = dot(ctx.worldNormal, normalize(_WorldSpaceLightPos0.xyz - ctx.worldPos));

	ndotl = saturate(ndotl) * ctx.shadow;

	ctx.result.rgb += lerp(ctx.dimmed, ctx.albedo, ndotl) * _LightColor0.rgb * lightShadowAndAtten;
}

void applyRim(inout ShadingContext ctx, in v2f i)
{
#if _RIM_ON
	half vdotl = dot(ctx.worldNormal, ctx.worldViewDir);
	vdotl = tex2D(_RimLUTTex, saturate(vdotl * 0.5 + 0.5)).r;

	ctx.result.rgb += vdotl * ctx.albedo * _RimIntensity;

#endif
}

void applySpecular(inout ShadingContext ctx, in v2f i)
{
	half3 worldNormal = ctx.worldNormal;

	half3 worldRLight = normalize(reflect(half3(0, -1, 0), worldNormal));

	half2 specUV = half2(saturate(dot(worldRLight, ctx.worldViewDir) * 0.5 + 0.5), 0.5);

	half4 spec = tex2D(_SpecularLUTTex, specUV);
	spec = spec * ctx.albedo.a;
	spec.rgb *= ctx.albedo.rgb;

	ctx.result.rgb += spec;
}

void shadingContext(inout ShadingContext ctx, in v2f i, in fixed vface)
{
	ctx = (ShadingContext)0;
	ctx.vface = vface;
	fetchAlbedoAndDimmed(ctx, i);
	fetchShadowTerm(ctx, i);
	fetchWorldNormal(ctx, i);

	ctx.result = half4(0, 0, 0, ctx.albedo.a);
}


half dither(in v2f i)
{
	half d1 = Bayer(i.pos.xy + float2(UNITY_MATRIX_MV._14, UNITY_MATRIX_MV._24));
	//half d2 = InterleavedGradientNoise(i.pos.xy);
	//return (d1 + d2) * 0.5;
	return d1;
}

void fade(inout ShadingContext ctx, in v2f i)
{
	half viewZ = i.worldPosAndZ.w;
	half d = dither(i);

	half fading = _FadeOut;
	fading = fading * 2.0 - 1.0;
	clip(d - fading);

#if _TEXTURE_FADE_OUT_ON
	clip(d + ctx.albedo.a);
#endif

	half bZ = _ProjectionParams.y * 2;
	half eZ = _ProjectionParams.y * 6;
	half rZ = eZ - bZ;
	half f = (viewZ - bZ) / rZ; // do not clamp f to [0, 1]

	f = f + d * rZ;
	clip(f);
}


half4 frag_base (v2f i, fixed vface : VFACE) : SV_Target
{
    ShadingContext ctx;
    shadingContext(ctx, i, vface);

   	fade(ctx, i);

	applyLightingFwdBase(ctx, i);

	applyRim(ctx, i);

	applySpecular(ctx, i);

    return ctx.result;
}


half4 frag_add (v2f i, fixed vface : VFACE) : SV_Target
{
    ShadingContext ctx;
    shadingContext(ctx, i, vface);

    fade(ctx, i);

    applyLightingFwdAdd(ctx, i);

    return ctx.result;
}