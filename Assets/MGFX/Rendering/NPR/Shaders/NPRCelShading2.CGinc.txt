///
/// Vertex
///
struct appdata
{
    float4 vertex : POSITION;
    float3 normal : NORMAL;
    float2 texcoord : TEXCOORD0;
#if _OVERLAY_ON
    float2 texcoord1 : TEXCOORD1;

	#ifndef LIGHTMAP_OFF
	float2 lmapcoord : TEXCOORD2;
	#endif

	#ifndef DYNAMICLIGHTMAP_OFF
	float2 dlmapcoord : TEXCOORD3;
	#endif

#else
	#ifndef LIGHTMAP_OFF
	float2 lmapcoord : TEXCOORD1;
	#endif

	#ifndef DYNAMICLIGHTMAP_OFF
	float2 dlmapcoord : TEXCOORD2;
	#endif

#endif

#if _NORMAL_MAP_ON
	float4 tangent : TANGENT;
#endif
};

struct v2f
{
    float4 uv : TEXCOORD0;
    SHADOW_COORDS(1) // put shadows data into TEXCOORD1
    float4 worldPosAndZ : TEXCOORD2;

#if _NORMAL_MAP_ON
	float4 tanSpace0 : TEXCOORD3;
	float4 tanSpace1 : TEXCOORD4;
	float4 tanSpace2 : TEXCOORD5;
#else
	float3 worldNormal : TEXCOORD3;
#endif

#ifndef LIGHTMAP_OFF
	float4 lmap : TEXCOORD6;
#endif

    float4 pos : SV_POSITION;
};

v2f vert (appdata v)
{
    v2f o;
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
    o.uv = v.texcoord.xyxy;
#if _OVERLAY_ON
    o.uv.zw = v.texcoord1;
#endif
    float3 worldNormal = UnityObjectToWorldNormal(v.normal);

#if _NORMAL_MAP_ON
	float3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
	float tangentSign = v.tangent.w * unity_WorldTransformParams.w;
	float3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
	o.tanSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, 0);
	o.tanSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, 0);
	o.tanSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, 0);
#else
	o.worldNormal = worldNormal;
#endif

    o.worldPosAndZ.xyz = mul(_Object2World, v.vertex).xyz;

#ifndef LIGHTMAP_OFF
	o.lmap = v.lmapcoord.xyxy * unity_LightmapST.xyxy + unity_LightmapST.zwzw;
#endif

#ifndef DYNAMICLIGHTMAP_OFF
	o.lmap.zw = v.dlmapcoord.xy;
#endif

    COMPUTE_EYEDEPTH(o.worldPosAndZ.w);
    // compute shadows data
    TRANSFER_SHADOW(o)
    return o;
}

///
/// Fragment
///
uniform sampler2D _MainTex;

uniform float _FadeOut;

#if _NORMAL_MAP_ON
uniform sampler2D _NormalMapTex;
#endif

#if _DIM_ON
uniform sampler2D _DimTex;
#endif

#if _OVERLAY_ON
uniform sampler2D _OverlayTex;
#endif

#if _DIFFUSE_LUT_ON
uniform sampler2D _DiffuseLUTTex;
#endif

#if _RIM_ON
uniform sampler2D _RimLUTTex;
uniform float _RimIntensity;
#endif

#if _EDGE_ON
uniform sampler2D _MudNPREdgeTex; // global property
uniform float4 _MudNPREdgeTex_TexelSize;
uniform float4 _EdgeColor;
uniform float _EdgeAutoColor;
uniform float _EdgeAutoColorFactor;
#endif

half3 decodeWorldNormal(in v2f i, in fixed vface)
{
#if _NORMAL_MAP_ON
	half3 tanNormal = UnpackNormal(tex2D(_NormalMapTex, i.uv.xy));
	half3 worldNormal;
	worldNormal.x = dot(i.tanSpace0.xyz, tanNormal);
	worldNormal.y = dot(i.tanSpace1.xyz, tanNormal);
	worldNormal.z = dot(i.tanSpace2.xyz, tanNormal);
	return normalize(worldNormal) * vface;
#else
	return normalize(i.worldNormal) * vface;
#endif
}

half dither(in v2f i)
{
	half d1 = Bayer(i.pos.xy + mul(UNITY_MATRIX_MV, float4(0, 0, 0, 1)).xy);
	//half d1 = Bayer(i.pos.xy + float2(UNITY_MATRIX_MV._13, UNITY_MATRIX_MV._23));
	half d2 = InterleavedGradientNoise(i.pos.xy);

	//return clamp(d2 + d1 * 0.5, -1, 1);
	//return clamp(d1 + d2 * 0.0625, -1, 1);
	//return (d1 + d2) * 0.5;
	return d1;
	//return d2;
}

half shadowTerm(in v2f i)
{
	half s = SHADOW_ATTENUATION(i);
	return s;
}

half shadowTermWithDither(in v2f i)
{
	half s = SHADOW_ATTENUATION(i);
	half d = InterleavedGradientNoise(i.pos.xy * 0.5 + iGlobalTime);
	s = clamp(s * (s + 0.25 * d), 0, 1);
	//d = d * 0.5 + 0.5;
	//d = (1-cos(d * d * 3.1415926)) / 2;
	//s = lerp(1 - pow(1-s, 2), s, d);
	return s;
}

void fade(in v2f i, fixed vface)
{
	half viewZ = i.worldPosAndZ.w;
	half d = dither(i);

	half fading = _FadeOut * 2.0 - 1.0;
	clip(d - fading);

	//if (vface < 1)
	//	clip(d);

	half bZ = _ProjectionParams.y * 2;
	half eZ = _ProjectionParams.y * 6;
	half rZ = eZ - bZ;
	half f = (viewZ - bZ) / rZ; // do not clamp f to [0, 1]

	f = f + d * rZ;
	clip(f);
}

half3 lighting(in v2f i, in half3 albedo, in half ndotl, in half shadow)
{
#if _DIM_ON
	half3 dark = tex2D(_DimTex, i.uv.xy);
#else
	half3 dark = pow(albedo * 0.9, 2.0);
#endif

#if _DIFFUSE_LUT_ON
	ndotl = tex2D(_DiffuseLUTTex, saturate(ndotl * 0.5 + 0.5) * shadow).r;
#else
	ndotl = saturate(ndotl) * shadow;
#endif
	return lerp(dark, albedo, ndotl) * _LightColor0.rgb;
}

#ifndef LIGHTMAP_OFF
half3 lightmapping(in v2f i, in half3 albedo, in half shadow)
{
#if _DIM_ON
	half3 dark = tex2D(_DimTex, i.uv.xy);
#else
	half3 dark = pow(albedo * 0.9, 2.0);
#endif
	half3 lmap = DecodeLightmap (UNITY_SAMPLE_TEX2D(unity_Lightmap, i.lmap.xy));
	half lum = Luminance(lmap) * shadow;
	return lerp(dark, albedo, lum) * lmap;
}
#endif

void darkout(inout half3 col, fixed vface)
{
	if (vface < 0)
    	col *= 0.25;
}

half4 fetchAlbedo(v2f i)
{
	half4 albedo = tex2D(_MainTex, i.uv.xy);
#if _OVERLAY_ON
	half4 overlay = tex2D(_OverlayTex, i.uv.zw);

	half t = overlay.a;
	t = (1-cos(t*3.1415926)) / 2;

	albedo.rgb = lerp(albedo.rgb, overlay.rgb, t);
#endif

	return albedo;
}

void applyEdge(inout half3 col, in v2f i)
{

#if _EDGE_ON
	half2 screenuv = i.pos.xy * _ScreenParams.zw - i.pos.xy;
	half isedge = tex2D(_MudNPREdgeTex, screenuv).r;

	half3 edgeColor = pow(col.rgb, _EdgeAutoColorFactor);
	edgeColor = lerp(_EdgeColor, edgeColor, _EdgeAutoColor);

	col.rgb = lerp(col.rgb, edgeColor, saturate(isedge * _EdgeColor.a * 4));
#endif

}

half4 frag_base (v2f i, fixed vface : VFACE) : SV_Target
{
   	fade(i, vface);

    fixed shadow = shadowTerm(i);

    half3 worldNormal = decodeWorldNormal(i, vface);

    half ndotl = dot(worldNormal, _WorldSpaceLightPos0.xyz);

    half4 albedo = fetchAlbedo(i);

    half3 col = 0;


#ifndef LIGHTMAP_OFF
	col = lightmapping(i, albedo, shadow);
#else
	col = lighting(i, albedo, ndotl, shadow);
#endif

#if _RIM_ON
	half3 worldViewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPosAndZ.xyz);

	half vdotl = dot(worldNormal, worldViewDir);
	vdotl = tex2D(_RimLUTTex, saturate(vdotl * 0.5 + 0.5)).r;

	col += vdotl * albedo * _RimIntensity;

#endif

    darkout(col, vface);

    applyEdge(col, i);

    return half4(col, 1);
}


half4 frag_add (v2f i, fixed vface : VFACE) : SV_Target
{
	fade(i, vface);

    fixed shadow = shadowTerm(i);

    half3 worldNormal = decodeWorldNormal(i, vface);

    half ndotl = dot(worldNormal, _WorldSpaceLightPos0.xyz);

    half4 albedo = fetchAlbedo(i);

    half3 col = lighting(i, albedo, ndotl, shadow);

    darkout(col, vface);

    MGFX_LIGHT_ATTENUATION(lightAtten, i, i.worldPosAndZ.xyz);
    col *= lightAtten * shadow;

    return half4(col, 1);
}